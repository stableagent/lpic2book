# **موضوع 200: برنامه‌ریزی ظرفیت**

### **200.1 اندازه‌گیری و عیب‌یابی مصرف منابع**

**وزن:** 6

**توضیحات:** داوطلبان باید بتوانند منابع سخت‌افزاری و پهنای باند شبکه را اندازه‌گیری کنند و مشکلات منابع را شناسایی و عیب‌یابی کنند.

**نواحی کلیدی دانش:**

* اندازه‌گیری مصرف CPU
* اندازه‌گیری مصرف حافظه
* اندازه‌گیری ورودی/خروجی دیسک
* اندازه‌گیری ورودی/خروجی شبکه
* اندازه‌گیری عملکرد فایروال و مسیریابی
* نگاشت مصرف پهنای باند کلاینت
* تطبیق/همبستگی علائم سیستم با مشکلات محتمل
* برآورد عملکرد و شناسایی گلوگاه‌ها در سیستم شامل شبکه

**موارد زیر فهرست جزئی از فایل‌ها، اصطلاحات و ابزارهای استفاده شده است:**

* iostat
* netstat
* w
* top
* sar
* فرآیندهای مسدود شده بر روی I/O
* blocks out
* vmstat
* pstree, ps
* lsof
* uptime
* swap
* blocks in

کامپیوترها هنگ می‌کنند، مردم نالید می‌کنند و برنامه‌ها با تاخیر اجرا می‌شوند. مدیریت همه این مشکلات بر عهده مدیران سیستم است. مهم نیست که صحبت از یک کامپیوتر واحد باشد یا جایی در ابر. ما به برخی ابزارها نیاز داریم تا رفتار یک سیستم را کاوش کنیم تا راه‌حلی پیدا کنیم. مشکلات عملکرد دو ریشه اصلی دارند، گاهی اوقات کمبود منابع سیستم مانند CPU، حافظه، HDD یا حتی شبکه باعث آن‌ها می‌شود، گاهی اوقات ما به عنوان انسان اشتباهاتی مرتکب می‌شویم. وقتی پارادوکسی بین آنچه انتظار داریم، آنچه مورد نیاز است و نحوه پیکربندی کامپیوترها وجود داشته باشد، سیستم هنگ می‌کند.

### اندازه‌گیری مصرف حافظه

RAM مانند دروازه‌ای برای یک شهر است، همه چیز از طریق RAM عبور می‌کند. اگر ما یک فرآیند داشته باشیم، باید ابتدا در RAM بارگذاری شود تا بعداً توسط CPU سرویس‌دهی شود. CPU cacheهای خود را از داده‌های RAM تغذیه می‌کند. کاربران چه کار می‌کنند؟ اگر کاربر بخواهد برخی داده‌ها را از هارد دیسک بخواند، در RAM بارگذاری می‌شود و سپس کاربر می‌تواند با آن کار کند.

![](.gitbook/assets/200.1-bigpicture.jpg)

همانطور که مشاهده می‌شود، RAM بسیار مشغول است و همیشه مورد نیاز است. لینوکس از برخی تکنیک‌ها برای غلبه بر مشکل استفاده می‌کند، برای ساده‌سازی، بیایید اصطلاحات حافظه را توضیح دهیم:

| مورد | توضیحات |
| :--- | :--- |
| Page | بلوک‌هایی که در حافظه استفاده می‌شوند، معمولاً با اندازه 4K |
| Paging | برای دریافت حافظه از حافظه ثانویه به حافظه اصلی استفاده می‌شود |
| Swap | حافظه شبیه‌سازی شده روی HDD |
| Virtual Memory | حافظه کلی قابل تخصیص، \[معروف به فضای آدرس فرآیند\] لینوکس از ترابایت‌های حافظه مجازی پشتیبانی می‌کند و از TLB برای تخصیص حافظه فیزیکی استفاده می‌کند. |
| Translation Look Aside Buffer\(TLB\) | نوعی cache که ترجمه بین RAM و حافظه مجازی را سرعت می‌دهد، در RAM ذخیره می‌شود |
| Page cache | صفحات حافظه اخیراً استفاده شده در اینجا ذخیره می‌شوند\(نه cpu cache \) برای داده‌های پارک شده استفاده می‌شود |
| Dirty Cache | داده‌هایی که منتظر رفتن به HDD از RAM هستند\(مانند بافر کار می‌کند\) |
| Buffers | برای برخی دستگاه‌های بلوکی و metadata فایل‌سیستم cache استفاده می‌شود. واقعاً مهم نیست |

بیایید با برخی ابزارها و دستورات ببینیم چه اتفاقی در داخل می‌افتد.

```
root@server1:~# vmstat
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 2  0  98012  79256  12136 319060    4   17   170    93   85  174  4  1 95  0  0
```

دستور vmstat وضعیت حافظه مجازی و برخی اطلاعات دیگر را نشان می‌دهد. برای بررسی دوره‌ای با فاصله زمانی می‌توانید از `vmstat 2 5` استفاده کنید. بیایید دستور free را امتحان کنیم:

```
root@server1:~# free -h
              total        used        free      shared  buff/cache   available
Mem:           971M        637M         93M         36M        241M        116M
Swap:          1.0G        403M        617M
```

اگر از گزینه -h استفاده کنید می‌توانید مقادیر قابل خواندن برای انسان را ببینید، می‌توانید از `-m` برای مگابایت و `-g` برای نمای گیگابایت استفاده کنید.

همانطور که می‌بینید 241M به buff/cache اختصاص داده شده است. برای پاک کردن buff/cache:

`echo 3 > /proc/sys/vm/drop_caches ; free -h`

این سیستم فقط 1 گیگابایت رم دارد، پس طبیعتاً شروع به استفاده از swap می‌کند، swappiness چیست؟

Swappiness پارامتر کرنل است که تعیین می‌کند کرنل لینوکس شما چه مقدار (و چند بار) محتوای RAM را به swap کپی می‌کند. مقدار پیش‌فرض این پارامتر "60" است و می‌تواند هر مقداری از "0" تا "100" را بگیرد. هرچه مقدار پارامتر swappiness بالاتر باشد، کرنل شما به شکل تهاجمی‌تری swap می‌کند.

```
root@server1:~# cd /proc/sys/vm/
root@server1:/proc/sys/vm# cat swappiness 
60
root@server1:/proc/sys/vm# echo 90 > swappiness
```

### نظارت بر CPU

باری که بر سیستم خود گذاشته‌اید را با دستور uptime نظارت و اندازه‌گیری کنید:

```
root@server1:~# uptime
 06:05:24 up  7:02,  1 user,  load average: 0.85, 1.04, 1.08
```

دستور uptime واضح است uptime را نشان می‌دهد :)، تعداد کاربران فعلی وارد شده و میانگین بار در 1 دقیقه گذشته، 5 دقیقه گذشته و 15 دقیقه گذشته. روشی که uptime میانگین بار سیستم را محاسبه می‌کند بر اساس میانگین بار CPU و ورودی/خروجی دیسک است. اما روشی که میانگین بار را نشان می‌دهد بر اساس # هسته‌های CPU است. پس برای یافتن % بار واقعی سیستم نیاز به برخی محاسبات داریم:

```
(میانگین بار / تعداد هسته‌های cpu) x 100 ===> %میانگین بار واقعی در سیستم ما
```

پس اگر فراتر از قابلیت CPU خود می‌روید. نیاز به بررسی بیشتر دارید. گاهی اوقات CPU گلوگاه است و گاهی اوقات دیسک گلوگاه است. دستور top اینجا هست تا به ما کمک کند:

```
top - 05:06:59 up  6:04,  1 user,  load average: 0.44, 0.16, 0.05
Tasks: 239 total,   3 running, 236 sleeping,   0 stopped,   0 zombie
%Cpu(s): 98.9 us,  1.1 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem :   994868 total,    77944 free,   594552 used,   322372 buff/cache
KiB Swap:  1045500 total,   571124 free,   474376 used.   180436 avail Mem 

   PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND     
  8738 root      20   0    7480     96      0 R 93.0  0.0   0:26.89 stress      
  7478 myuser     20   0  884192 110216  48640 S  4.7 11.1   4:01.21 oxide-rend+ 
     1 root      20   0  185136   3436   2300 S  0.0  0.3   0:03.40 systemd     
     2 root      20   0       0      0      0 S  0.0  0.0   0:00.01 kthreadd    
     4 root       0 -20       0      0      0 S  0.0  0.0   0:00.00 kworker/0:+ 
     6 root      20   0       0      0      0 S  0.0  0.0   0:04.64 ksoftirqd/0 
     7 root      20   0       0      0      0 R  0.0  0.0   0:04.30 rcu_sched   
     8 root      20   0       0      0      0 S  0.0  0.0   0:00.00 rcu_bh      
     9 root      rt   0       0      0      0 S  0.0  0.0   0:00.00 migration/0 
    10 root       0 -20       0      0      0 S  0.0  0.0   0:00.00 lru-add-dr+ 
    11 root      rt   0       0      0      0 S  0.0  0.0   0:00.10 watchdog/0  
    12 root      20   0       0      0      0 S  0.0  0.0   0:00.00 cpuhp/0     
    13 root      20   0       0      0      0 S  0.0  0.0   0:00.00 kdevtmpfs   
    14 root       0 -20       0      0      0 S  0.0  0.0   0:00.00 netns       
    15 root      20   0       0      0      0 S  0.0  0.0   0:00.09 khungtaskd  
    16 root      20   0       0      0      0 S  0.0  0.0   0:00.00 oom_reaper  
    17 root       0 -20       0      0      0 S  0.0  0.0   0:00.00 writeback
```

دستور top اطلاعاتی درباره uptime سیستم، میانگین بار و اطلاعات تفصیلی درباره فرآیندها به ما می‌دهد. top همچنین ترفندهایی دارد:

| کلید | توضیحات |
| :--- | :--- |
| فشردن "1" | بار تمام هسته‌های cpu را نشان می‌دهد |
| "shift" + "<" یا ">" | بر اساس ستون‌های مختلف مرتب می‌کند |
| "shift" + "p" | بر اساس استفاده CPU مرتب می‌کند |
| "shift" + "m" | بر اساس استفاده حافظه مرتب می‌کند |
| فشردن "c" | مسیر absolute فرآیند را نشان می‌دهد |
| فشردن "z" | فرآیندهای در حال اجرا را رنگی می‌کند |
| فشردن "d" و سپس عدد تاخیر | به صورت پیش‌فرض دستور top هر 3.0 ثانیه اجرا می‌شود |
| فشردن "k" و PID فرآیند | فرآیند را با استفاده از PID می‌کشد |
| فشردن "r" و PID فرآیند | برای renice کردن فرآیند |
| "shift" + "w" | برای نوشتن نتایج دستور top |
| فشردن "q" | برای خروج |

پس دستور top برای نظارت بر CPU و RAM مفید است و همچنین فرآیندهای I/O wait را به ما نشان می‌دهد. برای جزئیات بیشتر بیایید به خط سوم نتیجه دستور top نگاه کنیم. لینوکس از نظر سیستم عامل دو فضا دارد، فضای کاربر و فضای سیستم، دستور top فرآیندها را به این روش طبقه‌بندی می‌کند:

```
us:% زمان CPU صرف شده در فضای کاربر #####لینوکس دو فضا از نظر سیستم عامل دارد، فضای کاربر و فضای کرنل 
sy:% زمان CPU صرف شده در فضای کرنل####
ni:% زمان CPU صرف شده در فرآیندهای اولویت پایین
id:% زمان CPU صرف شده در حالت بیکار
wa:زمان انتظار I/O cpu (یا) % زمان CPU صرف شده در انتظار (روی دیسک)####### IO WAIT ######
hi: % زمان CPU صرف شده در سرویس/پردازش وقفه‌های سخت‌افزاری
si:% زمان CPU صرف شده در سرویس/پردازش وقفه‌های نرم‌افزاری
st:% زمان CPU در انتظار غیرارادی توسط cpu مجازی در حالی که hypervisor در حال سرویس‌دهی به پردازنده دیگر است
```

آیا wa را دیدید؟ فرآیندهای IO wait را نشان می‌دهد و زمانی اتفاق می‌افتد که گلوگاه دیسک باشد. در این شرایط فرآیندی نیاز به خواندن برخی داده‌ها از هارد دیسک دارد، اما هارد دیسک بسیار مشغول است و نمی‌تواند داده‌ها را در زمان مورد نیاز بخواند. پس فرآیند بد باید منتظر بماند تا دیسک کارش را انجام دهد. فرآیند I/O Blocked است و می‌خوابد :\) از نظر CPU فرآیند در یک "خواب غیرقابل قطع" می‌رود. این شرایط بسیار بد است زیرا حتی نمی‌توانیم آن فرآیند را بکشیم :\( پس با دستور top بر فرآیندها نظارت کنید و همیشه مطمئن شوید که % فرآیندهای منتظر I/O صفر است.

### اندازه‌گیری ورودی/خروجی دیسک

اگر بالاخره تشخیص دادیم که مشکل سرعت دیسک است، باید ورودی/خروجی دیسک را نظارت کنیم، دستور top شگفت‌انگیز است اما باید بدانیم کدام برنامه باعث مشکل شده است. ما از iotop استفاده می‌کنیم \[باید بر اساس توزیع شما نصب شود، کرنل >= 2.6\]:

```
Total DISK READ :     805.10 B/s | Total DISK WRITE :      43.24 K/s
Actual DISK READ:     805.10 B/s | Actual DISK WRITE:      34.59 K/s
   TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO>    COMMAND         
   343 be/3 root        0.00 B/s    5.50 K/s  0.00 %  0.08 % [jbd2/sda1-8]
  3399 be/4 payam       0.00 B/s    2.36 K/s  0.00 %  0.05 % firefox [~M Worker]
  3344 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.01 % [kworker/u256:0]
  3539 be/4 _apt        0.00 B/s   35.38 K/s  0.00 %  0.00 % http
  1894 be/4 payam     805.10 B/s    0.00 B/s  0.06 %  0.00 % ibus-ui-gtk3
     1 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % init auto noprompt
     2 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kthreadd]
     4 be/0 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kworker/0:0H]
  2053 be/4 payam       0.00 B/s    0.00 B/s  0.00 %  0.00 % indicator~e [gdbus]
     6 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [ksoftirqd/0]
     7 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [rcu_sched]
     8 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [rcu_bh]
     9 rt/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [migration/0]
    10 be/0 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [lru-add-drain]
    11 rt/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [watchdog/0]
    12 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [cpuhp/0]
    13 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [cpuhp/1]
    14 rt/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [watchdog/1]
    15 rt/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [migration/1]
    16 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [ksoftirqd/1]
    18 be/0 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kworker/1:0H
```

ابزار دیگری وجود دارد که اطلاعات کمتری به ما می‌دهد اما سریع و مفید است، مانند vmstat که درباره آن صحبت کردیم، ما iostat داریم که عکس فوری از وضعیت فعلی ورودی/خروجی دیسک می‌دهد: \[iostat بخشی از بسته sysstat است و باید نصب شود\]:

```
root@server1:~# iostat
Linux 4.10.0-28-generic (server1)     11/29/2017     _x86_64_    (4 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           2.95    4.12    8.76    1.46    0.00   82.72

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda             126.67      2487.11      5265.57    3756449    7952952
```

ابزار دیگری که وجود دارد sar است، بله این خنده‌دار است زیرا این نام پرنده‌ای در فارسی است :\) اما در اینجا مخفف "System Activity Report" است. برای اجرای دستور sar باید تاخیر و زمان را برای آن تعریف کنید:

```
root@server1:~# sar 1 7
Linux 4.10.0-28-generic (server1)     11/29/2017     _x86_64_    (4 CPU)

12:26:42 AM     CPU     %user     %nice   %system   %iowait    %steal     %idle
12:26:43 AM     all      0.25      0.00      0.00      0.00      0.00     99.75
12:26:44 AM     all      0.76      0.00      0.25      0.00      0.00     98.99
12:26:45 AM     all      0.50      0.00      0.50      0.00      0.00     99.00
12:26:46 AM     all      0.50      0.00      0.75      0.00      0.00     98.74
12:26:47 AM     all      0.51      0.00      0.51      0.00      0.00     98.99
12:26:48 AM     all      0.50      0.00      0.25      0.00      0.00     99.25
12:26:49 AM     all      0.75      0.00      0.75      0.00      0.00     98.49
Average:        all      0.54      0.00      0.43      0.00      0.00     99.03
```

گاهی اوقات نیاز داریم بدانیم چه فایل‌هایی در سیستم ما باز هستند. چه مشکل عملکرد داشته باشیم یا فقط برای نظارت بر آنچه قبل از ریبوت کردن کامپیوتر اتفاق می‌افتد. lsof به ما "لیست فایل‌های باز" می‌دهد:

```
COMMAND     PID  TID             USER   FD      TYPE             DEVICE SIZE/OFF       NODE NAME
systemd       1                  root  cwd       DIR                8,1     4096          2 /
systemd       1                  root  rtd       DIR                8,1     4096          2 /
systemd       1                  root  txt       REG                8,1  1577232     135885 /lib/systemd/systemd
systemd       1                  root  mem       REG                8,1    18976     136484 /lib/x86_64-linux-gnu/libuuid.so.1.3.0
systemd       1                  root  mem       REG                8,1   262408     136292 /lib/x86_64-linux-gnu/libblkid.so.1.1.0
systemd       1                  root  mem       REG                8,1    14608     136324 /lib/x86_64-linux-gnu/libdl-2.23.so
systemd       1                  root  mem       REG                8,1   456632     136429 /lib/x86_64-linux-gnu/libpcre.so.3.13.2
systemd       1                  root  mem       REG                8,1  1868984     136300 /lib/x86_64-linux-gnu/libc-2.23.so
systemd       1                  root  mem       REG                8,1   138696     136446 /lib/x86_64-linux-gnu/libpthread-2.23.so
systemd       1                  root  mem       REG                8,1   286824     136376 /lib/x86_64-linux-gnu/libmount.so.1.1.0
systemd       1                  root  mem       REG                8,1    64144     136282 /lib/x86_64-linux-gnu/libapparmor.so.1.4.0
systemd       1                  root  mem       REG                8,1    92864     136363 /lib/x86_64-linux-gnu/libkmod.so.2.3.0
systemd       1                  root  mem       REG                8,1   117288     136290 /lib/x86_64-linux-gnu/libaudit.so.1.0.0
systemd       1                  root  mem       REG                8,1    55904     136416 /lib/x86_64-linux-gnu/libpam.so.0.83.1
systemd       1                  root  mem       REG                8,1   252152     136457 /lib/x86_64-linux-gnu/libseccomp.so.2.2.3
systemd       1                  root  mem       REG                8,1    31712     136454 /lib/x86_64-linux-gnu/librt-2.23.so
systemd       1                  root  mem       REG                8,1    23128     136303 /lib/x86_64-linux-gnu/libcap.so.2.24
systemd       1                  root  mem       REG                8,1   130224     136458 /lib/x86_64-linux-gnu/libselinux.so.1
systemd       1                  root  mem       REG                8,1   162632     136272 /lib/x86_64-linux-gnu/ld-2.23.so
```

lsof لیست بسیار بسیار طولانی از فایل‌های باز به ما می‌دهد، می‌توانید بخشی از آن را در بالا ببینید. اما ما معمولاً از آن با grep استفاده می‌کنیم و همچنین می‌توانیم از آن برای کاربر خاص lsof -u myuser استفاده کنیم.

### اندازه‌گیری ورودی/خروجی شبکه

با گسترش اینترنت و رشد شبکه‌های شخصی، اهمیت شبکه رشد می‌کند. زمانی که می‌خواهیم بررسی کنیم چه چیزی در شبکه باعث مشکل شده است، باید کل مسیر را در نظر بگیریم، از ابتدا تا انتها و بالعکس. این مانند صحبت درباره ترافیک ماشین در شهرهای بزرگ است. بیایید با برخی دستورات و ابزارها آشنا شویم.

#### iftop

بیایید عضو دیگری به دستورات سری top اضافه کنیم، iftop. iftop اطلاعاتی درباره sessionهای روی NIC شما می‌دهد و آن‌ها را بر اساس نرخ انتقال مرتب می‌کند.

```
                12.5Kb          25.0Kb          37.5Kb          50.0Kb    62.5Kb
└───────────────┴───────────────┴───────────────┴───────────────┴───────────────
192.168.10.131             => ec2-52-35-5-132.us-west-2   444b   1.76Kb   450b
                           <=                             320b   5.51Kb  1.38Kb
192.168.10.131             => ec2-35-162-5-204.us-west-     0b   1.58Kb   405b
                           <=                               0b   5.51Kb  1.38Kb
192.168.10.131             => sof02s18-in-f42.1e100.net     0b   1.33Kb   340b
                           <=                               0b   4.77Kb  1.19Kb
192.168.10.131             => 192.168.10.2                  0b   1.87Kb   691b
                           <=                               0b   3.25Kb  0.99Kb
192.168.10.131             => sof02s18-in-f14.1e100.net     0b    494b    123b
                           <=                               0b    696b    174b
192.168.10.131             => 93.184.220.29                 0b    768b    192b
                           <=                               0b      0b      0b
192.168.10.131             => a95-101-72-121.deploy.aka     0b     32b     95b
                           <=                               0b    339b    102b
224.0.0.252                => 192.168.10.1                  0b      0b      0b
                           <=                               0b    170b    212b
239.255.255.250            => 192.168.10.1                  0b      0b      0b
                           <=                             804b    161b     40b
────────────────────────────────────────────────────────────────────────────────
TX:             cum:   11.8KB   peak:   20.5Kb  rates:    444b   7.80Kb  2.24Kb
RX:                    28.0KB           62.1Kb           1.10Kb  20.4Kb  5.46Kb
TOTAL:                 39.8KB           82.6Kb           1.53Kb  28.2Kb  7.70Kb
```

مانند top، می‌توانید از کلیدهای < > برای مرتب کردن بر اساس ستون‌های مختلف استفاده کنید، و می‌توانید 1 یا 2 یا 3 را فشار دهید تا بر اساس فعالیت‌های شبکه 2ثانیه، 10ثانیه یا 40ثانیه گذشته مرتب شود. همچنین می‌توانید با استفاده از iftop -i eth1 اینترفیس خاصی را انتخاب کنید.

#### nload

Network Load nload ابزار مفید دیگری است، این بار برای نظارت بر پهنای باند فعلی.

```
Device ens33 [192.168.10.131] (1/2):
================================================================================
Incoming:


                                                       Curr: 235.20 kBit/s
                                                       Avg: 452.10 kBit/s
             #|..                                      Min: 0.00 Bit/s
    .|    ..#####|.                ..  ||.|      ..    Max: 2.56 MBit/s
###.##.  .#########| ......  ..|..###|.####| ..||## .  Ttl: 35.37 MByte
Outgoing:


                                                       Curr: 10.84 kBit/s
                                                       Avg: 46.62 kBit/s
                                                       Min: 0.00 Bit/s
                                                       Max: 370.35 kBit/s
             ..                                        Ttl: 1.69 MByte
```

اگر لذت بردید سپس ifstat را برای خودتان امتحان کنید.

برای تست اتصال بین دو گره شبکه ابزار iperf عالی داریم.

```
### ماشین A 192.168.10.131 ### به عنوان سرور###
root@server1:~# iperf -s
------------------------------------------------------------
Server listening on TCP port 5001
TCP window size: 85.3 KByte (default)
------------------------------------------------------------
[  4] local 192.168.10.131 port 5001 connected with 192.168.10.130 port 41784
[ ID] Interval       Transfer     Bandwidth
[  4] 0.0-10.0 sec  3.44 GBytes  2.95 Gbits/sec


###ماشین B 192.168.10.130 ### به عنوان کلاینت ###
iperf -c 192.168.10.131
------------------------------------------------------------
Client connecting to 192.168.10.131, TCP port 5001
TCP window size: 85.0 KByte (default)
------------------------------------------------------------
[  3] local 192.168.10.130 port 41784 connected with 192.168.10.131 port 5001
[ ID] Interval       Transfer     Bandwidth
[  3] 0.0-10.0 sec  3.44 GBytes  2.96 Gbits/sec
```

از آنجایی که هر دو گره در مثال من ماشین‌های مجازی هستند، می‌توانید پهنای باند شگفت‌انگیز 2.95 Gbits/sec را ببینید. چه کسی می‌داند که روزی در آینده این ممکن است در دنیای واقعی اتفاق بیفتد :\)

و بالاخره، بیایید ابزار کوچکی برای بررسی سرعت اینترنت از خط فرمان معرفی کنم:

apt install speedtest-cli

```
root@server1:~# speedtest
Retrieving speedtest.net configuration...
Retrieving speedtest.net server list...
Testing from WestHost (107.182.226.165)...
Selecting best server based on latency...
Hosted by Sprint (New York City, NY) [2.13 km]: 581.08 ms
Testing download speed........................................
Download: 1.24 Mbit/s
Testing upload speed..................................................
Upload: 3.23 Mbit/s
```

.

.

.

.