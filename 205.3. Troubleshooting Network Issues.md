# 205.3 عیب‌یابی مشکلات شبکه

## **205.3 عیب‌یابی مشکلات شبکه**

**وزن:** 4

**توضیحات:** داوطلبان باید بتوانند مشکلات رایج در راه‌اندازی شبکه را شناسایی و برطرف کنند؛ از جمله آشنایی با مسیر فایل‌های پیکربندی پایه و دستورهای مرتبط.

**نواحی کلیدی دانش:**

* محل و محتوای فایل‌های محدودسازی دسترسی (access restriction)
* ابزارهای پیکربندی و دستکاری رابط‌های شبکه اترنت
* ابزارهای مدیریت جدول‌های مسیریابی
* ابزارهای نمایش وضعیت‌های شبکه
* ابزارهای به‌دست آوردن اطلاعات درباره پیکربندی شبکه
* روش‌های به‌دست آوردن اطلاعات درباره سخت‌افزارهای شناسایی‌شده و استفاده‌شده
* فایل‌های initialization سیستم و محتوای آن‌ها (فرآیند SysV init)
* آگاهی از NetworkManager و اثر آن بر پیکربندی شبکه

**اصطلاحات و ابزارها:**

* ip
* ifconfig
* route
* ss
* netstat
* /etc/network/, /etc/sysconfig/network-scripts/
* ping, ping6
* traceroute, traceroute6
* mtr
* hostname
* فایل‌های log سیستم مثل /var/log/syslog، /var/log/messages و systemd journal
* dmesg
* /etc/resolv.conf
* /etc/hosts
* /etc/hostname, /etc/HOSTNAME
* /etc/hosts.allow, /etc/hosts.deny

فایل‌های پیکربندی شبکه در سیستم‌های Debian و RedHat متفاوت هستند.

| Debian         | RedHat                         |
| -------------- | ------------------------------ |
| /etc/network/  | /etc/sysconfig/network-scripts |

بیایید هر دو را دقیق‌تر ببینیم. در Debian/Ubuntu:

```
root@server1:/etc/network# tree
.
├── if-down.d
│   ├── avahi-autoipd
│   ├── resolvconf
│   ├── upstart
│   └── wpasupplicant -> ../../wpa_supplicant/ifupdown.sh
├── if-post-down.d
│   ├── avahi-daemon -> ../if-up.d/avahi-daemon
│   ├── wireless-tools
│   └── wpasupplicant -> ../../wpa_supplicant/ifupdown.sh
├── if-pre-up.d
│   ├── ethtool
│   ├── wireless-tools
│   └── wpasupplicant -> ../../wpa_supplicant/ifupdown.sh
├── if-up.d
│   ├── 000resolvconf
│   ├── avahi-autoipd
│   ├── avahi-daemon
│   ├── ethtool
│   ├── openssh-server
│   ├── upstart
│   └── wpasupplicant -> ../../wpa_supplicant/ifupdown.sh
├── interfaces
└── interfaces.d

5 directories, 18 files
```

و در CentOS:

```
[root@server1 network-scripts]# tree
.
├── ifcfg-ens33
├── ifcfg-ens34
├── ifcfg-lo
├── ifdown -> ../../../usr/sbin/ifdown
├── ifdown-bnep
├── ifdown-eth
├── ifdown-ib
├── ifdown-ippp
├── ifdown-ipv6
├── ifdown-isdn -> ifdown-ippp
├── ifdown-post
├── ifdown-ppp
├── ifdown-routes
├── ifdown-sit
├── ifdown-Team
├── ifdown-TeamPort
├── ifdown-tunnel
├── ifup -> ../../../usr/sbin/ifup
├── ifup-aliases
├── ifup-bnep
├── ifup-eth
├── ifup-ib
├── ifup-ippp
├── ifup-ipv6
├── ifup-isdn -> ifup-ippp
├── ifup-plip
├── ifup-plusb
├── ifup-post
├── ifup-ppp
├── ifup-routes
├── ifup-sit
├── ifup-Team
├── ifup-TeamPort
├── ifup-tunnel
├── ifup-wireless
├── init.ipv6-global
├── network-functions
└── network-functions-ipv6

0 directories, 38 files
```

در هر دو توزیع اسکریپت‌ها و دایرکتوری‌های زیادی وجود دارد و بسیاری از ویژگی‌های شبکه لینوکس زیر همین مسیرها پیکربندی می‌شوند.

یک مرور سریع (LPIC-1):

### فایل‌های پیکربندی شبکه

| Debian                  | RedHat                                     |
| ----------------------- | ------------------------------------------ |
| /etc/network/interfaces | /etc/sysconfig/network-scripts/ifcfg-ens33 |

در سیستم‌های Debian-based معمولاً همه اینترفیس‌ها در یک فایل پیکربندی می‌شوند، اما در توزیع‌های RedHat-based برای هر NIC یک فایل جداگانه وجود دارد.

Debian:

```
# interfaces(5) file used by ifup(8) and ifdown(8)
auto lo
iface lo inet loopback
#auto ens33

iface ens33 inet static
address 192.168.10.152
netmask 255.255.255.0
network 192.168.10.0
broadcast 192.168.10.255
gateway 192.168.10.2
dns-nameservers 8.8.8.8
gateway 192.168.10.2
```

RedHat:

```
TYPE=Ethernet
PROXY_METHOD=none
BROWSER_ONLY=no
BOOTPROTO=dhcp
DEFROUTE=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_FAILURE_FATAL=no
IPV6_ADDR_GEN_MODE=stable-privacy
NAME=ens33
UUID=8b2c8289-3eac-42cb-bf01-113cf1cac8ad
DEVICE=ens33
ONBOOT=no
DNS1=8.8.8.8
```

در سیستم‌های Debian-based، تنظیمات Default Gateway معمولاً داخل فایل پیکربندی شبکه تعریف می‌شود. اما در سیستم‌های RedHat-based، Default Gateway در فایل `/etc/sysconfig/network` پیکربندی می‌شود.

## /etc/resolv.conf

این فایل لیست DNS serverها را برای name resolution نگه می‌دارد.

در Debian:

```
root@server1:~# cat /etc/resolv.conf 
# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
```

در RedHat:

```
# Generated by NetworkManager
search localdomain
nameserver 192.168.10.2
nameserver 8.8.8.8
```

وقتی تنظیمات DNS را با فایل `/etc/resolv.conf` تغییر می‌دهیم باید توجه کنیم که این تغییرات دائمی نیستند. با reboot ممکن است تنظیمات به حالت اولیه برگردند.

فایل `/etc/resolv.conf` توسط چیزهای مختلف overwrite می‌شود: اسکریپت‌ها و فایل‌های `/etc/sysconfig/network-scripts/ifcfg-xxx` در RedHat یا `/etc/network/interfaces` در Debian، فایل `/etc/sysconfig/network` (در برخی موارد)، DHCP client (بسته به پیکربندی)، و NetworkManager. به عنوان مثال برای ایجاد تغییر دائمی در resolv.conf از طریق تنظیمات DHCP client، این گزینه را از حالت comment خارج کنید:

```
root@server1:/# cat /etc/dhcp/dhclient.conf | grep prepend\ domain-name-servers
#prepend domain-name-servers 127.0.0.1;
```

یک روش دیگر این است که فایل‌های head/base/tail را زیر `resolv.conf.d` ویرایش کنیم:

```
root@server1:/etc# tree resolvconf/
resolvconf/
├── interface-order
├── resolv.conf.d
│   ├── base
│   └── head
├── update.d
│   └── libc
└── update-libc.d
    └── avahi-daemon

3 directories, 5 files
```

* `base`: وقتی داده دیگری پیدا نشود استفاده می‌شود
* `head`: برای header فایل resolv.conf استفاده می‌شود؛ می‌تواند برای این استفاده شود که یک DNS server همیشه اولین مورد در لیست باشد
* `tail`: هر چیزی در tail به انتهای resolv.conf ساخته‌شده append می‌شود

با اضافه شدن systemd، دنبال کردن منشأ این تغییرات سخت‌تر شده است، چون بخش زیادی از startup پنهان شده است. `systemd-resolved` یک caching-only name server است که resolv.conf را طوری تغییر می‌دهد که خودش هم در search قرار بگیرد. همچنین برای compatibility فایل `/run/systemd/resolve/resolv.conf` را تولید می‌کند که ممکن است به عنوان symlink از `/etc/resolv.conf` استفاده شود (Ubuntu):

```
root@server1:/etc# ls -l | grep resolv.conf 
lrwxrwxrwx  1 root root      29 Nov 26 02:38 resolv.conf -> ../run/resolvconf/resolv.conf
```

## traceroute, traceroute6

`traceroute` مسیر (route) بسته‌ها تا رسیدن به host مقصد را نمایش می‌دهد.

```
root@server1:~# traceroute google.com
traceroute to google.com (74.125.236.132), 30 hops max, 60 byte packets
1  220.224.141.129 (220.224.141.129)  89.174 ms  89.094 ms  89.054 ms
2  115.255.239.65 (115.255.239.65)  109.037 ms  108.994 ms  108.963 ms
3  124.124.251.245 (124.124.251.245)  108.937 ms  121.322 ms  121.300 ms
4  * 115.255.239.45 (115.255.239.45)  113.754 ms  113.692 ms
5  72.14.212.118 (72.14.212.118)  123.585 ms  123.558 ms  123.527 ms
6  72.14.232.202 (72.14.232.202)  123.499 ms  123.475 ms  143.523 ms
7  216.239.48.179 (216.239.48.179)  143.503 ms  95.106 ms  95.026 ms
8  bom03s02-in-f4.1e100.net (74.125.236.132)  94.980 ms  104.989 ms  104.954 ms
```

اما traceroute چطور این اطلاعات را به ما می‌دهد؟ traceroute هم مثل ping از packetهای ICMP استفاده می‌کند. ولی از فیلد TTL در IP header استفاده می‌کند. TTL چیست؟

به زبان ساده «عمر بسته در شبکه» است. هر بار که packet در یک router نگه داشته می‌شود، مقدار TTL یک واحد کم می‌شود. اگر router بسته‌ای را با TTL=1 دریافت کند، آن packet را forward نمی‌کند و آن را دور می‌اندازد (discard).

بعد از دور انداختن packet، router یک پیام خطای ICMP با مضمون “Time exceeded” به سمت مبدا می‌فرستد. packet برگشتی ICMP شامل IP address همان router است.

![](.gitbook/assets/traceroute3.png)

پس traceroute با ارسال packetهایی با TTL شروع از 1 و افزایش مرحله‌ای TTL کار می‌کند. هر بار یک router بسته را می‌گیرد و اگر TTL=1 باشد آن را drop می‌کند و خطای ICMP را با IP خودش برمی‌گرداند؛ این دقیقاً چیزی است که traceroute نیاز دارد. به این شکل traceroute به صورت مرحله‌ای IP همه routerها بین مبدا و مقصد را به دست می‌آورد.

| چند دستور مفید traceroute     | توضیحات |
| ------------------------------ | ------- |
| traceroute -i ens33 google.com | مشخص کردن اینترفیس مورد استفاده |
| traceroute google.com -n       | غیرفعال کردن تبدیل hostname و IP (عدم resolve) |
| traceroute google.com -w 0.2   | تنظیم زمان انتظار برای پاسخ |
| traceroute google.com -q 5     | تنظیم تعداد query در هر hop (پیش‌فرض: 3) |
| traceroute google.com -f 8     | تنظیم TTL شروع |
| traceroute -6 ipv6.google.com  | traceroute با IPv6 |

`traceroute6` معادل `traceroute -6` است.

## mtr

درباره ping و traceroute صحبت کردیم. اگر قابلیت هر دو را در یک ابزار داشته باشیم چه؟ `mtr` یک ابزار قدرتمند برای عیب‌یابی شبکه است که به مدیران سیستم اجازه می‌دهد وضعیت شبکه را بررسی کنند و گزارش‌های مفیدی تولید کنند. (ممکن است نصب نباشد؛ نصبش کنید و استفاده کنید):

```
root@server1:~# mtr google.com
```

```
HOST: server1                      Loss%   Snt   Last   Avg  Best  Wrst StDev
  1. inner-cake                    0.0%    10    2.8   2.1   1.9   2.8   0.3
  2. outer-cake                    0.0%    10    3.2   2.6   2.4   3.2   0.3
  3. 68.85.118.13                  0.0%    10    9.8  12.2   8.7  18.2   3.0
  4. po-20-ar01.absecon.nj.panjde  0.0%    10   10.2  10.4   8.9  14.2   1.6
  5. be-30-crs01.audubon.nj.panjd  0.0%    10   10.8  12.2  10.1  16.6   1.7
  6. pos-0-12-0-0-ar01.plainfield  0.0%    10   13.4  14.6  12.6  21.6   2.6
  7. pos-0-6-0-0-cr01.newyork.ny.  0.0%    10   15.2  15.3  13.9  18.2   1.3
  8. pos-0-4-0-0-pe01.111eighthav  0.0%    10   16.5  16.2  14.5  19.3   1.3
  9. as15169-3.111eighthave.ny.ib  0.0%    10   16.0  17.1  14.2  27.7   3.9
 10. 72.14.238.232                 0.0%    10   19.1  22.0  13.9  43.3  11.1
 11. 209.85.241.148                0.0%    10   15.1  16.2  14.8  20.2   1.6
 12. lga15s02-in-f104.1e100.net    0.0%    10   15.6  16.9  15.2  20.6   1.7
```

mtr چطور کار می‌کند؟ مثل ابزارهای دیگر عیب‌یابی شبکه (از جمله ping و traceroute) از packetهای ICMP برای تست ارتباط/ترافیک بین دو نقطه استفاده می‌کند و مثل traceroute با افزایش TTL اطلاعات مسیر را جمع‌آوری می‌کند.

| سوئیچ‌های مفید mtr   | توضیحات |
| -------------------- | ------- |
| -h , --help          | نمایش خلاصه گزینه‌های خط فرمان |
| -v , --version       | نمایش نسخه نصب‌شده mtr |
| -r , --report        | report mode؛ mtr به تعداد cycle مشخص‌شده با -c اجرا می‌شود و سپس آمار را چاپ می‌کند و خارج می‌شود |
| -n , --no-dns        | نمایش IP عددی و عدم resolve کردن hostname |
| -F serverslist.txt   | خواندن لیست سرورها از فایل |
| -4                   | فقط IPv4 |
| -6                   | فقط IPv6 |

## hostname

hostnameها برای این استفاده می‌شوند که بتوانیم یک ماشین را در شبکه به شکل قابل خواندن برای انسان شناسایی کنیم. در لینوکس hostname را می‌توان با دستور `hostname` به سادگی تغییر داد:

```
root@server1:~# hostname
server1
root@server1:~# hostname myhostname
root@server1:~# hostname
myhostname
```

این کار hostname را بلافاصله تغییر می‌دهد، اما یک مشکل دارد: بعد از reboot، hostname اصلی برمی‌گردد.

### تنظیم دائمی hostname سیستم

روش دائمی کردن hostname در RedHat و Ubuntu متفاوت است و در نسخه‌های جدید (با systemd) هم تغییر کرده است.

* در توزیع‌های قدیمی‌تر (SysV) می‌توان با ویرایش فایل `/etc/hostname` hostname را تغییر داد و سپس یک رکورد در `/etc/hosts` اضافه کرد:

```
127.0.0.1 myhostname
```

و در نهایت:

```
hostname restart
```

* در سیستم‌های RHEL/CentOS که از init استفاده می‌کنند، hostname با تغییر `/etc/sysconfig/network` تنظیم می‌شود:

```
[root@myhostname ~]# cat /etc/sysconfig/network
NETWORKING=yes
NETWORKING_IPV6=yes
HOSTNAME=myhostname
```

* نسخه‌های جدیدتر توزیع‌هایی مثل Ubuntu، Debian، CentOS، Fedora، RedHat و ... با systemd می‌آیند و دستور `hostnamectl` را برای مدیریت hostname فراهم می‌کنند:

```
root@server1:~# hostnamectl set-hostname myhostname
```

## /etc/hosts

وقتی ماشین بالا می‌آید، قبل از اینکه DNS در دسترس باشد باید mapping برخی hostnameها به IP را بداند. این mapping در فایل `/etc/hosts` نگه داشته می‌شود. وقتی name server وجود ندارد، برنامه‌های شبکه این فایل را بررسی می‌کنند تا IP متناظر با یک hostname را به دست بیاورند.

```
root@server1:~# 
cat /etc/hosts
127.0.0.1    localhost
127.0.1.1    ubuntu

# The following lines are desirable for IPv6 capable hosts
::1     ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
```

## /etc/hosts.allow , /etc/hosts.deny

TCP wrappers را یادتان هست؟ یک مرور سریع: TCP wrappers برای محدود کردن دسترسی به سرویس‌های شبکه‌ای که روی سرور لینوکس اجرا می‌شوند استفاده می‌شود. با این حال باید تاکید کنیم که TCP wrappers جایگزین یک firewall درست پیکربندی‌شده نیست. می‌توانیم آن را مانند یک host-based ACL ببینیم، نه به عنوان ابزار نهایی امنیت سیستم. اما این موضوع چه ربطی به hosts.allow و hosts.deny دارد؟

![](.gitbook/assets/TCPWrapper.jpg)

وقتی یک درخواست شبکه به سرور می‌رسد، TCP wrappers با استفاده از `hosts.allow` و `hosts.deny` (به همین ترتیب) تعیین می‌کند آیا کلاینت اجازه استفاده از یک سرویس مشخص را دارد یا نه.

به صورت پیش‌فرض این فایل‌ها خالی‌اند، کامنت شده‌اند یا وجود ندارند؛ بنابراین همه چیز از لایه TCP wrappers عبور می‌کند و سیستم برای حفاظت کامل به firewall متکی می‌ماند. برای محدودسازی باید فایل‌های hosts.allow/hosts.deny را ویرایش کنید. اول مطمئن شوید وجود دارند:

```
root@server1:~# ls -l /etc/hosts.allow /etc/hosts.deny 
-rw-r--r-- 1 root root 411 Aug  1  2017 /etc/hosts.allow
-rw-r--r-- 1 root root 711 Aug  1  2017 /etc/hosts.deny
```

Syntax هر دو فایل:

```
<services> : <clients> [: <option1> : <option2> : ...]
```

* `services` لیستی جدا شده با comma از سرویس‌هایی است که rule باید روی آن‌ها اعمال شود.
* `clients` لیستی جدا شده با comma از hostnameها یا IP addressهایی است که rule روی آن‌ها اثر می‌گذارد.

Wildcardهای زیر پشتیبانی می‌شوند:

| توضیحات Wildcardها |
| ------------------ |
| ALL همه چیز را match می‌کند؛ هم برای client و هم برای service |
| LOCAL میزبان‌هایی را match می‌کند که در FQDN خود نقطه ندارند، مثل localhost |
| KNOWN یعنی hostname/آدرس میزبان/کاربر مشخص است |
| UNKNOWN برعکس KNOWN است |
| PARANOID اگر reverse DNS lookup در هر بار آدرس متفاوتی برگرداند، connection را قطع می‌کند |

* در نهایت یک لیست اختیاری از actionها (جدا شده با colon) مشخص می‌کند هنگام trigger شدن rule چه اتفاقی بیفتد.

متاسفانه همه سرویس‌های شبکه از TCP wrappers پشتیبانی نمی‌کنند. برای اینکه ببینید یک برنامه از TCP wrappers پشتیبانی می‌کند یا نه، باید `libwrap` بین shared libraryهایی باشد که آن برنامه استفاده می‌کند: `ldd /path/to/binary | grep libwrap`

```
root@server1:~# ldd $(which sshd) | grep libwrap
    libwrap.so.0 => /lib/x86_64-linux-gnu/libwrap.so.0 (0x00007fc2bbfca000)
```

خب، به عنوان مثال اگر بخواهیم فقط به 192.168.10.151 و localhost اجازه SSH و FTP بدهیم و بقیه را deny کنیم، این دو خط را در `/etc/hosts.deny` اضافه می‌کنیم:

```
sshd,vsftpd : ALL
ALL : ALL
```

و این خط را در `/etc/hosts.allow`:

```
sshd,vsftpd : 192.168.10.151,LOCAL
```

و تمام.
