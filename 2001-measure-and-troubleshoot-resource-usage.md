# 200.1. اندازه‌گیری و عیب‌یابی مصرف منابع

## **200.1 Measure and Troubleshoot Resource Usage**

**وزن:** 6

**توضیحات:** داوطلبان باید بتوانند منابع سخت‌افزاری و پهنای باند شبکه را اندازه‌گیری کنند و مشکلات منابع را شناسایی و عیب‌یابی نمایند.

**نواحی کلیدی دانش:**

* اندازه‌گیری مصرف CPU
* اندازه‌گیری مصرف حافظه
* اندازه‌گیری ورودی/خروجی دیسک
* اندازه‌گیری ورودی/خروجی شبکه
* اندازه‌گیری throughput فایروال و مسیریابی
* نگاشت مصرف پهنای باند کلاینت
* تطبیق/همبستگی علائم سیستم با مشکلات احتمالی
* برآورد throughput و شناسایی گلوگاه‌ها در یک سیستم شامل شبکه

**لیست زیر لیست جزئی از فایل‌ها، اصطلاحات و ابزارهای استفاده شده است:**

* iostat
* netstat
* w
* top
* sar
* فرآیندهای مسدود شده بر روی I/O
* blocks out
* vmstat
* pstree, ps
* lsof
* uptime
* swap
* blocks in

کامپیوترها هنگ می‌کنند، مردم نالید می‌کنند و برنامه‌ها با تاخیر اجرا می‌شوند. مدیریت همه این مشکلات بر عهده مدیران سیستم است. مهم نیست که صحبت از یک کامپیوتر واحد باشد یا جایی در ابر. ما به برخی ابزارها نیاز داریم تا رفتار یک سیستم را کاوش کنیم تا راه‌حلی پیدا کنیم. مشکلات عملکرد دو ریشه اصلی دارند، گاهی اوقات کمبود منابع سیستم مانند CPU، حافظه، HDD یا حتی شبکه باعث آن‌ها می‌شود، و گاهی اوقات ما به عنوان انسان اشتباهاتی مرتکب می‌شویم. وقتی پارادوکسی بین آنچه انتظار داریم، آنچه مورد نیاز است و نحوه پیکربندی کامپیوترها وجود داشته باشد، سیستم هنگ می‌کند.

## اندازه‌گیری مصرف حافظه

RAM مانند دروازه‌ای برای یک شهر است، همه چیز از طریق RAM عبور می‌کند. اگر ما یک فرآیند داشته باشیم، باید ابتدا در RAM بارگذاری شود تا بعداً توسط CPU سرویس‌دهی شود. CPU cacheهای خود را از داده‌های RAM تغذیه می‌کند. کاربران چه کار می‌کنند؟ اگر کاربر بخواهد برخی داده‌ها را از هارد دیسک بخواند، در RAM بارگذاری می‌شود و سپس کاربر می‌تواند با آن کار کند.

![](.gitbook/assets/200.1-bigpicture.jpg)

همانطور که مشاهده می‌شود، RAM بسیار مشغول است و همیشه مورد نیاز است. لینوکس از برخی تکنیک‌ها برای غلبه بر مشکل استفاده می‌کند، برای ساده‌سازی، بیایید اصطلاحات حافظه را توضیح دهیم:

| مورد                               | توضیحات                                                                                                                                     |
| ---------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- |
| Page                               | بلوک‌هایی که در حافظه استفاده می‌شوند، معمولاً با اندازه 4K                                                                                    |
| Paging                             | برای دریافت حافظه از حافظه ثانویه به حافظه اصلی استفاده می‌شود                                                                                    |
| Swap                               | حافظه شبیه‌سازی شده روی HDD                                                                                                                         |
| Virtual Memory                     | کل حافظه قابل تخصیص، \[به عنوان فضای آدرس فرآیند شناخته می‌شود] لینوکس از ترابایت‌های حافظه مجازی پشتیبانی می‌کند و از TLB برای تخصیص حافظه فیزیکی استفاده می‌کند. |
| Translation Look aside Buffer(TLB) | نوعی cache که ترجمه بین RAM و حافظه مجازی را تسریع می‌کند، در RAM ذخیره می‌شود                                                           |
| Page cache                         | صفحات حافظه اخیراً استفاده شده اینجا ذخیره می‌شوند (نه CPU cache) برای داده‌های پارک شده استفاده می‌شود                                                                |
| Dirty Cache                        | داده‌هایی که منتظر هستند از RAM به HDD بروند (مانند buffer عمل می‌کنند)                                                                               |
| Buffers                            | برای برخی دستگاه‌های بلوکی و cache metadata فایل‌سیستم استفاده می‌شود. خیلی مهم نیست                                                                 |

بیایید با برخی ابزارها و دستورات ببینیم چه اتفاقی در حال رخ دادن است.

```
root@server1:~# vmstat
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 2  0  98012  79256  12136 319060    4   17   170    93   85  174  4  1 95  0  0
```

دستور vmstat وضعیت حافظه مجازی و برخی اطلاعات دیگر را نشان می‌دهد. برای بررسی دوره‌ای با فاصله زمانی می‌توانید از `vmstat 2 5` استفاده کنید. بیایید دستور free را امتحان کنیم:

```
root@server1:~# free -h
              total        used        free      shared  buff/cache   available
Mem:           971M        637M         93M         36M        241M        116M
Swap:          1.0G        403M        617M
```

اگر از گزینه -h استفاده کنید، مقادیر قابل خواندن برای انسان را می‌توانید ببینید، می‌توانید از `-m` برای نمایش مگابایت و `-g` برای نمایش گیگابایت استفاده کنید.

همانطور که می‌بینید، 241M به buff/cache تخصیص داده شده است. برای پاک کردن buff/cache:

`echo 3 > /proc/sys/vm/drop_caches ; free -h`

این سیستم فقط 1 گیگابایت RAM دارد، بنابراین واضح است که شروع به استفاده از swap می‌کند، swappiness چیست؟

Swappiness پارامتر هسته است که تعیین می‌کند هسته لینوکس شما چه مقدار (و چقدر اغلب) محتویات RAM را به swap کپی می‌کند. مقدار پیش‌فرض این پارامتر "60" است و می‌تواند هر مقداری از "0" تا "100" را بگیرد. هرچه مقدار پارامتر swappiness بالاتر باشد، هسته شما به طور تهاجمی‌تر swap می‌کند.

```
root@server1:~# cd /proc/sys/vm/
root@server1:/proc/sys/vm# cat swappiness
60
root@server1:/proc/sys/vm# echo 90 > swappiness
```

## مانیتورینگ CPU

بار را که بر روی سیستم خود قرار داده‌اند با دستور uptime مانیتور و اندازه‌گیری کنید:

```
root@server1:~# uptime
 06:05:24 up  7:02,  1 user,  load average: 0.85, 1.04, 1.08
```

دستور uptime واضحاً uptime را نشان می‌دهد :), تعداد کاربران لاگین شده فعلی، و میانگین بار در 1 دقیقه گذشته، 5 دقیقه گذشته و 15 دقیقه گذشته. روشی که uptime میانگین بار سیستم را محاسبه می‌کند بر اساس میانگین بار CPU و ورودی/خروجی دیسک است. اما روشی که Load Average را نشان می‌دهد بر اساس تعداد هسته‌های CPU است. بنابراین برای پیدا کردن درصد بار واقعی سیستم به برخی محاسبات نیاز داریم:

```
(Load average / number of cpu cores) x 100 ===> %real load average in our system
```

بنابراین اگر فراتر از قابلیت CPU خود می‌روید. شما نیاز به بررسی بیشتر دارید. گاهی اوقات CPU گلوگاه است و گاهی اوقات Disk گلوگاه است. دستور top اینجا برای کمک به ما آمده است:

```
top - 05:06:59 up  6:04,  1 user,  load average: 0.44, 0.16, 0.05
Tasks: 239 total,   3 running, 236 sleeping,   0 stopped,   0 zombie
%Cpu(s): 98.9 us,  1.1 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem :   994868 total,    77944 free,   594552 used,   322372 buff/cache
KiB Swap:  1045500 total,   571124 free,   474376 used.   180436 avail Mem

   PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND
  8738 root      20   0    7480     96      0 R 93.0  0.0   0:26.89 stress
  7478 myuser     20   0  884192 110216  48640 S  4.7 11.1   4:01.21 oxide-rend+
     1 root      20   0  185136   3436   2300 S  0.0  0.3   0:03.40 systemd
     2 root      20   0       0      0      0 S  0.0  0.0   0:00.01 kthreadd
     4 root       0 -20       0      0      0 S  0.0  0.0   0:00.00 kworker/0:+
     6 root      20   0       0      0      0 S  0.0  0.0   0:04.64 ksoftirqd/0
     7 root      20   0       0      0      0 R  0.0  0.0   0:04.30 rcu_sched
     8 root      20   0       0      0      0 S  0.0  0.0   0:00.00 rcu_bh
     9 root      rt   0       0      0      0 S  0.0  0.0   0:00.00 migration/0
    10 root       0 -20       0      0      0 S  0.0  0.0   0:00.00 lru-add-dr+
    11 root      rt   0       0      0      0 S  0.0  0.0   0:00.10 watchdog/0
    12 root      20   0       0      0      0 S  0.0  0.0   0:00.00 cpuhp/0
    13 root      20   0       0      0      0 S  0.0  0.0   0:00.00 kdevtmpfs
    14 root       0 -20       0      0      0 S  0.0  0.0   0:00.00 netns
    15 root      20   0       0      0      0 S  0.0  0.0   0:00.09 khungtaskd
    16 root      20   0       0      0      0 S  0.0  0.0   0:00.00 oom_reaper
    17 root       0 -20       0      0      0 S  0.0  0.0   0:00.00 writeback
```

دستور top اطلاعات در مورد uptime سیستم، میانگین بار، و اطلاعات دقیق در مورد فرآیندها را به ما می‌دهد. top همچنین چند ترفند دارد:

| کلید                                 | توضیحات                                  |
| ----------------------------------- | -------------------------------------------- |
| فشار دادن "1"                           | بار تمام هسته‌های CPU را نشان می‌دهد                     |
| "shift" + "<" یا ">"                | مرتب‌سازی top بر اساس ستون‌های مختلف           |
| "shift" + "p"                       | مرتب‌سازی بر اساس مصرف CPU                         |
| "shift" + "m"                       | مرتب‌سازی بر اساس مصرف حافظه                      |
| فشار دادن "c"                           | مسیر مطلق فرآیند را نشان می‌دهد              |
| فشار دادن "z"                           | فرآیند در حال اجرا را رنگی می‌کند                |
| فشار دادن "d" و سپس عدد تاخیر     | به طور پیش‌فرض دستور top هر 3.0 ثانیه اجرا می‌شود |
| فشار دادن "k" و وارد کردن PID فرآیند | کشتن فرآیند با استفاده از PID                |
| فشار دادن "r"  و PID فرآیند       | برای تغییر اولویت یک فرآیند                          |
| "shift" + "w"                       | برای نوشتن نتایج دستور top                 |
| فشار دادن "q"                           | برای خروج                                      |

بنابراین دستور top برای مانیتورینگ هر دو CPU و RAM مفید است و همچنین فرآیندهای I/O wait را به ما نشان می‌دهد. برای جزئیات بیشتر، بیایید به خط سوم نتیجه دستور top نگاهی بیندازیم. لینوکس دو فضا از دید سیستم عامل دارد، User space و System space، دستور top فرآیندها را به این صورت طبقه‌بندی می‌کند:

```
us:% زمان CPU صرف شده در فضای کاربر #####لینوکس دو فضا از دید سیستم عامل دارد، فضای کاربر و فضای هسته
sy:% زمان CPU صرف شده در فضای هسته####
ni:% زمان CPU صرف شده بر روی فرآیندهای اولویت پایین
id:% زمان CPU صرف شده در بیکاری
wa:io wait cpu time (یا) % زمان CPU صرف شده در انتظار (روی دیسک)#######  IO WAIT ######
hi: % زمان CPU صرف شده برای سرویس‌دهی/مدیریت وقفه‌های سخت‌افزاری
si:% زمان CPU صرف شده برای سرویس‌دهی/مدیریت وقفه‌های نرم‌افزاری
st:% زمان CPU در انتظار غیرارادی توسط CPU مجازی در حالی که hypervisor به پردازنده دیگری سرویس می‌دهد
```

wa را دیدید؟ آن فرآیندهای I/O wait را نشان می‌دهد و زمانی رخ می‌دهد که گلوگاه Disk است. در این شرایط، یک فرآیند نیاز به داده‌هایی دارد که از هارد دیسک خوانده شوند، اما هارد دیسک بسیار مشغول است و نمی‌تواند داده‌ها را در زمان لازم بخواند. بنابراین فرآیند فقیر باید منتظر بماند تا دیسک کار خود را انجام دهد. فرآیند I/O Blocked شده است و از نظر CPU می‌خوابد :) از نظر CPU فرآیند در یک "خواب غیرقابل وقفه" (Uninterruptible Sleep) می‌رود. این وضعیت خیلی بد است زیرا ما حتی نمی‌توانیم آن فرآیند را بکشیم :( بنابراین فرآیندها را با دستور top مانیتور کنید و همیشه مطمئن شوید که درصد فرآیندهای منتظر I/O صفر است.

## اندازه‌گیری ورودی/خروجی دیسک

اگر در نهایت متوجه شده‌ایم که مشکل سرعت دیسک است، باید ورودی/خروجی دیسک را مانیتور کنیم، دستور top فوق‌العاده است اما ما باید بدانیم چه برنامه‌ای باعث مشکل شده است. ما از iotop استفاده می‌کنیم \[بسته به توزیع شما باید نصب شود، kernel >= 2.6]:

```
Total DISK READ :     805.10 B/s | Total DISK WRITE :      43.24 K/s
Actual DISK READ:     805.10 B/s | Actual DISK WRITE:      34.59 K/s
   TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO>    COMMAND
   343 be/3 root        0.00 B/s    5.50 K/s  0.00 %  0.08 % [jbd2/sda1-8]
  3399 be/4 payam       0.00 B/s    2.36 K/s  0.00 %  0.05 % firefox [~M Worker]
  3344 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.01 % [kworker/u256:0]
  3539 be/4 _apt        0.00 B/s   35.38 K/s  0.00 %  0.00 % http
  1894 be/4 payam     805.10 B/s    0.00 B/s  0.06 %  0.00 % ibus-ui-gtk3
     1 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % init auto noprompt
     2 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kthreadd]
     4 be/0 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kworker/0:0H]
  2053 be/4 payam       0.00 B/s    0.00 B/s  0.00 %  0.00 % indicator~e [gdbus]
     6 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [ksoftirqd/0]
     7 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [rcu_sched]
     8 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [rcu_bh]
     9 rt/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [migration/0]
    10 be/0 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [lru-add-drain]
    11 rt/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [watchdog/0]
    12 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [cpuhp/0]
    13 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [cpuhp/1]
    14 rt/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [watchdog/1]
    15 rt/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [migration/1]
    16 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [ksoftirqd/1]
    18 be/0 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kworker/1:0H
```

ابزار دیگری وجود دارد که اطلاعات کمتری به ما می‌دهد اما سریع و کاربردی است، مانند vmstat که در مورد آن صحبت کردیم، ما iostat داریم که یک snapshot از وضعیت فعلی ورودی/خروجی دیسک را به ما می‌دهد: \[iostat بخشی از بسته sysstat است و باید نصب شود]:

```
root@server1:~# iostat
Linux 4.10.0-28-generic (server1)     11/29/2017     _x86_64_    (4 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           2.95    4.12    8.76    1.46    0.00   82.72

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda             126.67      2487.11      5265.57    3756449    7952952
```

ابزار دیگری وجود دارد که sar است، بله این خنده‌دار است زیرا این نام یک پرنده در فارسی است :) اما اینجا مخفف "System Activity Report" است. برای اجرای دستور sar باید تاخیر و زمان را برای آن تعریف کنید:

```
root@server1:~# sar 1 7
Linux 4.10.0-28-generic (server1)     11/29/2017     _x86_64_    (4 CPU)

12:26:42 AM     CPU     %user     %nice   %system   %iowait    %steal     %idle
12:26:43 AM     all      0.25      0.00      0.00      0.00      0.00     99.75
12:26:44 AM     all      0.76      0.00      0.25      0.00      0.00     98.99
12:26:45 AM     all      0.50      0.00      0.50      0.00      0.00     99.00
12:26:46 AM     all      0.50      0.00      0.75      0.00      0.00     98.74
12:26:47 AM     all      0.51      0.00      0.51      0.00      0.00     98.99
12:26:48 AM     all      0.50      0.00      0.25      0.00      0.00     99.25
12:26:49 AM     all      0.75      0.00      0.75      0.00      0.00     98.49
Average:        all      0.54      0.00      0.43      0.00      0.00     99.03
```

گاهی اوقات ما نیاز داریم بدانیم چه فایل‌هایی در سیستم ما باز هستند. اینکه ما مشکل عملکرد داریم یا فقط برای مانیتورینگ چه اتفاقی قبل از ریست کردن کامپیوتر می‌افتد. lsof به ما "LiSt of Open Files" (لیست فایل‌های باز) می‌دهد:

```
COMMAND     PID  TID             USER   FD      TYPE             DEVICE SIZE/OFF       NODE NAME
systemd       1                  root  cwd       DIR                8,1     4096          2 /
systemd       1                  root  rtd       DIR                8,1     4096          2 /
systemd       1                  root  txt       REG                8,1  1577232     135885 /lib/systemd/systemd
systemd       1                  root  mem       REG                8,1    18976     136484 /lib/x86_64-linux-gnu/libuuid.so.1.3.0
systemd       1                  root  mem       REG                8,1   262408     136292 /lib/x86_64-linux-gnu/libblkid.so.1.1.0
systemd       1                  root  mem       REG                8,1    14608     136324 /lib/x86_64-linux-gnu/libdl-2.23.so
systemd       1                  root  mem       REG                8,1   456632     136429 /lib/x86_64-linux-gnu/libpcre.so.3.13.2
systemd       1                  root  mem       REG                8,1  1868984     136300 /lib/x86_64-linux-gnu/libc-2.23.so
systemd       1                  root  mem       REG                8,1   138696     136446 /lib/x86_64-linux-gnu/libpthread-2.23.so
systemd       1                  root  mem       REG                8,1   286824     136376 /lib/x86_64-linux-gnu/libmount.so.1.1.0
systemd       1                  root  mem       REG                8,1    64144     136282 /lib/x86_64-linux-gnu/libapparmor.so.1.4.0
systemd       1                  root  mem       REG                8,1    92864     136363 /lib/x86_64-linux-gnu/libkmod.so.2.3.0
systemd       1                  root  mem       REG                8,1   117288     136290 /lib/x86_64-linux-gnu/libaudit.so.1.0.0
systemd       1                  root  mem       REG                8,1    55904     136416 /lib/x86_64-linux-gnu/libpam.so.0.83.1
systemd       1                  root  mem       REG                8,1   252152     136457 /lib/x86_64-linux-gnu/libseccomp.so.2.2.3
systemd       1                  root  mem       REG                8,1    31712     136454 /lib/x86_64-linux-gnu/librt-2.23.so
systemd       1                  root  mem       REG                8,1    23128     136303 /lib/x86_64-linux-gnu/libcap.so.2.24
systemd       1                  root  mem       REG                8,1   130224     136458 /lib/x86_64-linux-gnu/libselinux.so.1
systemd       1                  root  mem       REG                8,1   162632     136272 /lib/x86_64-linux-gnu/ld-2.23.so
```

lsof لیست بسیار طولانی از فایل‌های باز به ما می‌دهد، می‌توانید بخشی از آن را در بالا ببینید. اما معمولاً از آن با grep استفاده می‌کنیم و همچنین می‌توانیم آن را برای یک کاربر خاص lsof -u myuser استفاده کنیم.

## اندازه‌گیری ورودی/خروجی شبکه

با گسترش اینترنت و رشد شبکه‌های شخصی، اهمیت شبکه افزایش می‌یابد. وقتی می‌خواهیم کاوش کنیم چه چیزی باعث مشکل در شبکه شده است، باید کل مسیر را از ابتدا تا انتها و بالعکس در نظر بگیریم. این مانند صحبت در مورد ترافیک اتومبیل در شهرهای بزرگ است. بیایید با برخی دستورات و ابزارها آشنا شویم.

### iftop

بیایید عضو دیگری به دستورات سری top اضافه کنیم، iftop. iftop اطلاعات در مورد سشن‌های شما بر روی NIC به شما می‌دهد و آن‌ها را بر اساس نرخ انتقال مرتب می‌کند.

```
                12.5Kb          25.0Kb          37.5Kb          50.0Kb    62.5Kb
└───────────────┴───────────────┴───────────────┴───────────────┴───────────────
192.168.10.131             => ec2-52-35-5-132.us-west-2   444b   1.76Kb   450b
                           <=                             320b   5.51Kb  1.38Kb
192.168.10.131             => ec2-35-162-5-204.us-west-     0b   1.58Kb   405b
                           <=                               0b   5.51Kb  1.38Kb
192.168.10.131             => sof02s18-in-f42.1e100.net     0b   1.33Kb   340b
                           <=                               0b   4.77Kb  1.19Kb
192.168.10.131             => 192.168.10.2                  0b   1.87Kb   691b
                           <=                               0b   3.25Kb  0.99Kb
192.168.10.131             => sof02s18-in-f14.1e100.net     0b    494b    123b
                           <=                               0b    696b    174b
192.168.10.131             => 93.184.220.29                 0b    768b    192b
                           <=                               0b      0b      0b
192.168.10.131             => a95-101-72-121.deploy.aka     0b     32b     95b
                           <=                               0b    339b    102b
224.0.0.252                => 192.168.10.1                  0b      0b      0b
                           <=                               0b    170b    212b
239.255.255.250            => 192.168.10.1                  0b      0b      0b
                           <=                             804b    161b     40b
──────────────────────────────────────────────────────────────────────────────
TX:             cum:   11.8KB   peak:   20.5Kb  rates:    444b   7.80Kb  2.24Kb
RX:                    28.0KB           62.1Kb           1.10Kb  20.4Kb  5.46Kb
TOTAL:                 39.8KB           82.6Kb           1.53Kb  28.2Kb  7.70Kb
```

مانند top، می‌توانید از کلیدهای < > برای مرتب‌سازی بر اساس ستون‌های مختلف استفاده کنید، و می‌توانید 1 یا 2 یا 3 را فشار دهید تا بر اساس فعالیت‌های شبکه 2 ثانیه اخیر، 10 ثانیه یا 40 ثانیه مرتب شود. همچنین می‌توانید رابط مشخصی را با استفاده از iftop -i eth1 انتخاب کنید

### nload

Network Load nload ابزار کاربردی دیگری است، این بار برای مانیتورینگ پهنای باند فعلی.

```
Device ens33 [192.168.10.131] (1/2):
================================================================================
Incoming:


                                                        Curr: 235.20 kBit/s
                                                        Avg: 452.10 kBit/s
             #|..                                      Min: 0.00 Bit/s
    .|    ..#####|.                ..  ||.|      ..    Max: 2.56 MBit/s
###.##.  .#########| ......  ..|..###|.####| ..||## .  Ttl: 35.37 MByte
Outgoing:


                                                        Curr: 10.84 kBit/s
                                                        Avg: 46.62 kBit/s
                                                        Min: 0.00 Bit/s
                                                        Max: 370.35 kBit/s
             ..                                        Ttl: 1.69 MByte
```

اگر از آن لذت بردید، پس ifstat را برای خودتان امتحان کنید.

برای تست اتصال بین دو گره شبکه، ما ابزار خوب iperf داریم.

```
### MAchine A 192.168.10.131 ### به عنوان سرور###
root@server1:~# iperf -s
------------------------------------------------------------
Server listening on TCP port 5001
TCP window size: 85.3 KByte (default)
------------------------------------------------------------
[  4] local 192.168.10.131 port 5001 connected with 192.168.10.130 port 41784
[ ID] Interval       Transfer     Bandwidth
[  4]  0.0-10.0 sec  3.44 GBytes  2.95 Gbits/sec


###machine B 192.168.10.130 ### به عنوان کلاینت ###
iperf -c 192.168.10.131
------------------------------------------------------------
Client connecting to 192.168.10.131, TCP port 5001
TCP window size: 85.0 KByte (default)
------------------------------------------------------------
[  3] local 192.168.10.130 port 41784 connected with 192.168.10.131 port 5001
[ ID] Interval       Transfer     Bandwidth
[  3]  0.0-10.0 sec  3.44 GBytes  2.96 Gbits/sec
```

از آنجا که هر دو گره در مثال من ماشین‌های مجازی هستند، می‌توانید پهنای باند خیره‌کننده 2.95 Gbits/sec را ببینید. چه می‌داند روزی در آینده این اتفاق در دنیای واقعی رخ دهد :)

و در نهایت، بیایید یک ابزار کوچک برای بررسی سرعت اینترنت شما از خط فرمان معرفی کنیم:

apt install speedtest-cli

```
root@server1:~# speedtest
Retrieving speedtest.net configuration...
Retrieving speedtest.net server list...
Testing from WestHost (107.182.226.165)...
Selecting best server based on latency...
Hosted by Sprint (New York City, NY) [2.13 km]: 581.08 ms
Testing download speed........................................
Download: 1.24 Mbit/s
Testing upload speed..................................................
Upload: 3.23 Mbit/s
```

.

.

.

